/**
 *  Copyright (C) 2018 - Innovusion Inc.
 *
 *  All Rights Reserved.
 *
 *  $Id$
 */
#include <assert.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <getopt.h>
#include <fcntl.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netdb.h>
#include <errno.h>
#include <string.h>
#include <pthread.h>
#include <stdint.h>
#include <arpa/inet.h>
#include <sys/uio.h>

#include "src/inno_lidar_api.h"
#include "src/inno_lidar_api_experimental.h"

const double us_in_second_c = 1000000.0;
const double hundred_us_in_second_c = 10000.0;

static const int MAX_INS = 10;
static int verbose_flag_g = 0;
static int output_format_g = 0;
static int server_port_g = 0;
static int server_listen_fd_g = -1;
static int server_write_fd_g = -1;
static int frame_written_g = 0;
static int ip_instance_g = 0;
static int file_instance_g = 0;
static int handles_g[MAX_INS];
static const char *csv_filename_g = NULL;
static const char *udp_ip_g = NULL;
static FILE *csv_file_g = NULL;
static int static_perception_flag_g = 0;
static int static_frame_interval = 10;

/*
  The pointcloud-server listens on a specified TCP port. If there is no client 
  connected to it, the inno_frame generated by the sensor the will be dropped
  after the buffer is full. The buffer can store up to 20 frames (will be 
  configurable in a later release). Once it accepts a TCP connection request
  from any host, it starts to send data to the client until the client close
  connection. If the client cannot drain data fast enough, inno_frame will be
  dropped once the buffer is full. The pointcloud-server can stream data to
  only one client at a time. If there is already a client connected to the
  pointcloud-server, no other client can connect to the server until the
  connected client closes the connection. During the whole session, the client
  should not send any TCP data to the server.

  Once connected, the pointcloud-server (version 100) will send 8 or 4 bytes
  ASCII characters, e.g. "PTCD 120", to the client to indicate its version. 
  After that, it will send variable-sized inno_frame_packet one by one. Please
  note there is no separator/delimiter between two inno_frame_packet, so the
  client needs to calculate the size of each inno_frame_packet to know its
  boundary.
*/

/*
  streaming format:
  - starts with "PTCD 320", 8 bytes
  - followed by repeats of
  b. length in bytes of c, 4 bytes, long in network order
  c. lidar handle, 4 bytes, long in network order
  d. length in bytes of e, 4 bytes, long in network order
  e. frame structure without points
  f. length in bytes of g, 4 bytes, long in network order
  g. points structures

  streaming format:
  - starts with "PS31", 4 bytes
  - followed by repeats of
  b. length in bytes of c, 4 bytes, long in network order
  c. lidar handle, 4 bytes, long in network order
  d. length in bytes of e, 4 bytes, long in network order
  e. frame structure without points
  f. length in bytes of g, 4 bytes, long in network order
  g. points structures

  streaming format 3:
  - starts with "PS32", 4 bytes
  - followed by repeats of
  b. length in bytes of c, 4 bytes, long in network order
  c. lidar handle, 4 bytes, long in network order
  d. length in bytes of e, 4 bytes, long in network order
  e. inno_frame_header structure
  f. length in bytes of g, 4 bytes, long in network order
  g. inno_point/inno_cpoint/inno_bbox/inno_text structures,
     (depended on the type in the inno_frame_header)

*/

/*
  Please note that the following conditions should always be true
  - ntohl(size_of_lidar_context) == 4
  - ntohl(size_of_inno_frame) == sizeof(struct inno_frame)
  - ntohl(size_of_inno_points_array) == (sizeof(struct inno_point) * frame.points_number).
  - (the size of one inno_frame_packet on-wire) == 4 + 4 + 4 + sizeof(struct inno_frame) + 4 +
  - size_of_inno_points_array
*/
DEFINE_COMPACT_STRUCT(inno_frame_packet_120) {
  unsigned int size_of_lidar_context;  // always 4, in network order
  unsigned lidar_context;              // in network order
  // always == sizeof(struct inno_frame), in network order
  unsigned int size_of_inno_frame;
  // defined in inno_lidar_api.h in SDK, in little endian
  struct inno_frame frame;
  // size of points[], in network order
  unsigned int size_of_inno_points_array;
  // variable array of inno_point,
  // defined in inno_lidar_api.h in SDK, in little endian
  struct inno_point points[];
};
DEFINE_COMPACT_STRUCT_END

pthread_mutex_t write_mutex_s = PTHREAD_MUTEX_INITIALIZER;

bool use_tcp() {
  return udp_ip_g == NULL;
}

int write_buffer_to_socket_full(int fd, const char *buf, ssize_t input_len) {
  ssize_t len = input_len;
  while (len > 0) {
    ssize_t written = write(fd, buf, len);
    if (written < 0) {
      if (errno == EINTR) {
        continue;
      } else {
        return written;
      }
    } else if (written == 0) {
      return -1;
    }
    buf += written;
    len -= written;
  }
  return input_len;
}

int write_buffer_to_socket_with_length(int fd, const char *buf,
                                       ssize_t input_len) {
  uint32_t len = static_cast<uint32_t>(htonl(input_len));
  int ret = write_buffer_to_socket_full(fd, (const char*)&len, sizeof(len));
  int total = 0;
  if (ret >= 0) {
    total += ret;
    ret = write_buffer_to_socket_full(fd, buf, input_len);
  }
  if (ret >= 0) {
    total += ret;
    return total;
  } else {
    return ret;
  }
}

int setup_write_socket(int output_format) {
  if (server_port_g == 0) {
    return -1;
  }
  if (server_write_fd_g < 0) {
    int fd;
    struct sockaddr_in address;
    int addrlen = sizeof(address);
    if (use_tcp()) {
      fd = accept(server_listen_fd_g, (struct sockaddr *)&address,
                  reinterpret_cast<socklen_t*>(&addrlen));
      if (fd < 0) {
        if (errno != EWOULDBLOCK) {
          perror("accept");
          exit(EXIT_FAILURE);
        }
      } else {
        printf("Client connected.\n");
        const char *vstr = NULL;
        if (output_format == 1) {
          vstr = "PS31";
        } else if (output_format == 2 || output_format == 3) {
          vstr = "PS32";
        } else {
          vstr = "PTCD 320";
        }
        printf("Stream version %s\n", vstr);
        int ret = write_buffer_to_socket_full(fd, vstr, strlen(vstr));
        if (ret < 0) {
          fprintf(stderr, "Cannot write to client, close connection\n");
          close(fd);
          fd = -1;
        }
      }
    } else {
      if ((fd = socket(AF_INET, SOCK_DGRAM, 0)) < 0) {
        perror("socket");
        exit(EXIT_FAILURE);
      }
      /* Set up the server name */
      address.sin_family      = AF_INET;
      address.sin_port        = htons(server_port_g);
      if (inet_pton(AF_INET, udp_ip_g, &address.sin_addr) <= 0) {
        perror("inet_pton error\n");
        exit(EXIT_FAILURE);
      }
      if (connect(fd, (struct sockaddr *)&address, sizeof(address)) < 0) {
         perror("connect");
         exit(EXIT_FAILURE);
      }
      printf("udp socket ready\n");
    }
    server_write_fd_g = fd;
  }
  return server_write_fd_g;
}

void setup_tcp_server_socket() {
  if (server_port_g == 0) {
    printf("No server mode\n");
    return;
  }

  struct sockaddr_in address;
  int opt = 1;

  if ((server_listen_fd_g = socket(AF_INET, SOCK_STREAM, 0)) == 0) {
    perror("socket failed");
    exit(EXIT_FAILURE);
  }

  if (setsockopt(server_listen_fd_g, SOL_SOCKET, SO_REUSEADDR | SO_REUSEPORT,
                 &opt, sizeof(opt))) {
    perror("setsockopt");
    exit(EXIT_FAILURE);
  }

  int flags = fcntl(server_listen_fd_g, F_GETFL);
  if (flags < 0) {
    perror("fcntl F_GETFL failed");
    exit(EXIT_FAILURE);
  }

  if (fcntl(server_listen_fd_g, F_SETFL, flags | O_NONBLOCK) < 0) {
    perror("fcntl F_SETFL failed");
    exit(EXIT_FAILURE);
  }

  address.sin_family = AF_INET;
  address.sin_addr.s_addr = INADDR_ANY;
  address.sin_port = htons(server_port_g);

  if (bind(server_listen_fd_g, (struct sockaddr *)&address,
           sizeof(address)) < 0) {
    perror("bind failed");
    exit(EXIT_FAILURE);
  }

  if (listen(server_listen_fd_g, 3) < 0) {
    perror("listen");
    exit(EXIT_FAILURE);
  }

  // HACK: sleep 200 ms so the test program can catch all packets
  usleep(1000 * 200);

  printf("Server listen on %d\n", server_port_g);

  return;
}

int write_to_write_socket(int lidar_handle, void *context,
                          struct inno_frame *frame) {
  int ret;
  int h = htonl(intptr_t(context));
  int total = 0;
  if (use_tcp()) {
    ret = write_buffer_to_socket_with_length(server_write_fd_g,
                                             (const char *)&h, sizeof(h));
    if (ret >= 0) {
      total += ret;
      ret = write_buffer_to_socket_with_length(server_write_fd_g,
                                               (const char *)frame,
                                               sizeof(*frame));
    }
    if (ret >= 0) {
      total += ret;
      ret = write_buffer_to_socket_with_length( \
          server_write_fd_g,
          (const char *)&frame->points[0],
          sizeof(frame->points[0]) * frame->points_number);
    }
  } else {
    fprintf(stderr, "not supported format in UDP mode\n");
    exit(-1);
    // printf("written %d bytes\n", ret);
  }
  if (ret >= 0) {
    total += ret;
    return total;
  } else {
    return ret;
  }
}

int write_to_write_socket_cframe(int lidar_handle, void *context,
                                 struct inno_cframe_header *frame) {
  int ret;
  int h = htonl(intptr_t(context));
  int total = 0;
  int unit_size = 0;
  switch (frame->type) {
    case INNO_CFRAME_POINT:
      unit_size = sizeof(struct inno_point);
      break;
    case INNO_CFRAME_CPOINT:
      unit_size = sizeof(struct inno_cpoint);
      break;
    case INNO_CFRAME_BBOX:
      unit_size = sizeof(struct inno_bbox);
      break;
    case INNO_CFRAME_TEXT:
      unit_size = sizeof(struct inno_text);
      break;
    case INNO_CFRAME_ALARM:
      unit_size = sizeof(struct inno_alarm_message);
      break;
    default:
      fprintf(stderr, "invalid type %d\n", frame->type);
      exit(-1);
  }
  if (use_tcp()) {
    ret = write_buffer_to_socket_with_length(server_write_fd_g,
                                             (const char *)&h, sizeof(h));
    if (ret >= 0) {
      total += ret;
      ret = write_buffer_to_socket_with_length(server_write_fd_g,
                                               (const char *)frame,
                                               sizeof(*frame));
    }
    if (ret >= 0) {
      total += ret;
      ret = write_buffer_to_socket_with_length( \
          server_write_fd_g,
          &frame->c[0],
          unit_size * frame->item_number);
    }
  } else {
    unsigned int l0 = htonl(4);
    unsigned int l1 = htonl(sizeof(struct inno_cframe_header));
    unsigned int l2 = 0;
    struct iovec ios[7];
    char vstr_32[5] = "PS32";
    struct inno_cframe_header frame_out;
    memcpy(&frame_out, frame, sizeof(frame_out));
    if (output_format_g == 2 || output_format_g == 3) {
      ios[0].iov_base = reinterpret_cast<void *>(vstr_32);
    } else {
      fprintf(stderr, "not supported format %d in udp mode\n", output_format_g);
      exit(-2);
    }
    ios[0].iov_len = 4;
    ios[1].iov_base = &l0;
    ios[1].iov_len = 4;
    ios[2].iov_base = &h;
    ios[2].iov_len = sizeof(h);
    ios[3].iov_base = &l1;
    ios[3].iov_len = 4;
    ios[4].iov_base = &frame_out;
    ios[4].iov_len = sizeof(frame_out);
    ios[5].iov_len = 4;
    int base_len = ios[0].iov_len + ios[1].iov_len + ios[2].iov_len +
                   ios[3].iov_len + ios[4].iov_len + ios[5].iov_len;
    static int target_udp_len = 1400;
    int max_n = (target_udp_len - base_len) / unit_size;
    frame_out.sub_seq = 0;
    ret = 0;
    for (unsigned int i = 0; i < frame->item_number;
         i += max_n, frame_out.sub_seq++) {
      int n = frame->item_number - i;
      if (n > max_n) {
        n = max_n;
      }
      frame_out.item_number = n;
      unsigned int ll = unit_size * n;
      l2 = htonl(ll);
      ios[5].iov_base = &l2;
      ios[5].iov_len = 4;
      ios[6].iov_base = reinterpret_cast<void *>(&frame->points[i]);
      ios[6].iov_len = ll;
      int written = writev(server_write_fd_g, ios, 7);
      if (written < 0) {
        perror("writev");
        exit(EXIT_FAILURE);
      } else {
        ret += written;
      }
    }
  }
  if (ret >= 0) {
      total += ret;
      return total;
  } else {
    return ret;
  }
}

void inno_lidar_alarm_callback(int lidar_handle, void *context,
                               enum inno_alarm error_level,
                               enum inno_alarm_code error_code,
                               const char *error_message) {
  fprintf(stderr, "### [LIDAR-%d] LIDAR ALARM: level=%d, code=%d, message=%s\n",
          static_cast<int>(intptr_t(context)),
          error_level, error_code, error_message);

  if (error_level >= INNO_ALARM_CRITICAL &&
      error_code != INNO_ALARM_CODE_LIB_VERSION_MISMATCH) {
    fprintf(stderr, "critical alarm, exit\n");
    int instances = ip_instance_g + file_instance_g;
    for (int i = 0; i < instances; i++) {
      inno_lidar_stop(handles_g[i]);
      inno_lidar_close(handles_g[i]);
    }
    exit(error_code);
  }
  return;
}

int setup_csv_fd() {
  if (csv_filename_g == NULL) {
    return -1;
  }
  if (csv_file_g != NULL) {
    return 0;
  }
  int csv_file_fd = open(csv_filename_g, O_WRONLY | O_CREAT | O_TRUNC, 0644);
  if (csv_file_fd < 0) {
    fprintf(stderr, "cannot open %s. %s\n", csv_filename_g, strerror(errno));
    exit(-1);
  }
  csv_file_g = fdopen(csv_file_fd, "w");
  if (csv_file_g < 0) {
    fprintf(stderr, "cannot fdopen %s. %s\n", csv_filename_g, strerror(errno));
    exit(-2);
  }
  fprintf(csv_file_g, "lidar, frame, sub-frame, seq, "
          "point, timestamp, x, y, z, radius, reflectance, flags, "
          "scanid, scanidx\n");
  return 0;
}

void write_to_csv_file(int lidar_handle, void *context,
                       struct inno_frame *frame) {
  int h = intptr_t(context);
  double ts_start_s = frame->ts_us_start / us_in_second_c;

  for (unsigned int i = 0; i < frame->points_number; i++) {
    inno_point *p = &frame->points[i];
    fprintf(csv_file_g, "%d, %lu, %u, %u, %u, %.7f, "
            "%.3f, %.3f, %.3f, %.3f, %u, %u, %u, %u\n",
            h, frame->idx, frame->sub_idx, 0,
            i, p->ts_100us/hundred_us_in_second_c + ts_start_s,
            p->x, p->y, p->z,
            p->radius,
            static_cast<uint32_t>(p->ref),
            static_cast<uint32_t>(p->flags),
            static_cast<uint32_t>(p->scan_id),
            static_cast<uint32_t>(p->scan_idx));
  }
  return;
}

int inno_lidar_frame_callback(int lidar_handle, void *context,
                              struct inno_frame *frame) {
  // multiple souces need serialize writing
  pthread_mutex_lock(&write_mutex_s);

  double ts_start_s = frame->ts_us_start / us_in_second_c;
  printf("[LIDAR-%d] got frame %lu-%d: timestamp=%f-%f, "
         "t-sync=%d, conf=%u, %d points\r\n",
         lidar_handle, frame->idx, frame->sub_idx,
         ts_start_s,
         frame->ts_us_end/us_in_second_c, frame->timestamp_sync_type,
         frame->conf_level, frame->points_number);
  for (unsigned int i = 0; i < 2 && i < frame->points_number; i++) {
    if (i == 1) {
      i = frame->points_number - 1;
    }
    inno_point *p = &frame->points[i];
    printf("[LIDAR-%d]   *point[%5u] timestamp=%f "
           "x=%f y=%f z=%f radius=%f reflectance=%d flags=%d\r\n",
           lidar_handle, i,
           p->ts_100us/hundred_us_in_second_c + ts_start_s,
           p->x, p->y, p->z, p->radius,
           static_cast<int>(p->ref), static_cast<int>(p->flags));
  }

  if (setup_write_socket(output_format_g) >= 0) {
    // write to write_socket
    int ret = write_to_write_socket(lidar_handle, context, frame);
    if (ret < 0) {
      fprintf(stderr, "Client disconnect.\n");
      close(server_write_fd_g);
      server_write_fd_g = -1;
      frame_written_g = 0;
    } else {
      printf("[LIDAR-%d]   write %d bytes to client, %d in this session.\n",
             lidar_handle, ret, ++frame_written_g);
    }
  }
  if (setup_csv_fd() >= 0) {
    write_to_csv_file(lidar_handle, context, frame);
  }

  pthread_mutex_unlock(&write_mutex_s);
  return 0;
}

int inno_lidar_cframe_callback(int lidar_handle, void *context,
                              struct inno_cframe_header *frame) {
  // multiple souces need serialize writing
  pthread_mutex_lock(&write_mutex_s);

  double ts_start_s = frame->ts_us_start / us_in_second_c;
  printf("[LIDAR-%d] got cframe topic=%d type=%d seq=%lu-%d: "
         "timestamp=%f-%f, %d items\r\n",
         lidar_handle, frame->topic, frame->type, frame->idx, frame->sub_idx,
         ts_start_s,
         frame->ts_us_end/us_in_second_c, frame->item_number);
  for (unsigned int i = 0; i < 2 && i < frame->item_number; i++) {
    if (i == 1) {
      i = frame->item_number - 1;
    }
    if (frame->type == INNO_CFRAME_POINT) {
      inno_point *p = &frame->points[i];
      printf("[LIDAR-%d]   *point[%5u] timestamp=%f "
             "x=%f y=%f z=%f radius=%f reflectance=%d flags=%d\r\n",
             lidar_handle, i,
             p->ts_100us/hundred_us_in_second_c + ts_start_s,
             p->x, p->y, p->z, p->radius,
             static_cast<int>(p->ref), static_cast<int>(p->flags));
    } else if (frame->type == INNO_CFRAME_CPOINT) {
      inno_cpoint *p = &frame->cpoints[i];
      printf("[LIDAR-%d]   *point[%5u] "
             "radius=%f h_angle=%f v_angle=%f reflectance=%d flags=%d\r\n",
             lidar_handle, i,
             p->radius * static_cast<double>(100),
             p->h_angle * cpoint_angel_unit_c,
             p->v_angle * cpoint_angel_unit_c,
             static_cast<int>(p->ref), static_cast<int>(p->flags));
    } else if (frame->type == INNO_CFRAME_BBOX) {
      inno_bbox *p = &frame->bboxes[i];
      printf("[LIDAR-%d]   *bbox[%5u] "
             "x=%f y=%f z=%f w=%f h=%f d=%f pw=%f px=%f py=%f "
             "pz=%f label=%d value=%d alpha=%f c=%d sty=%d\r\n",
             lidar_handle, i,
             p->x, p->y, p->z, p->width, p->height, p->depth,
             p->pose_w, p->pose_x, p->pose_y, p->pose_z,
             p->label, p->value, p->alpha, p->color, p->style);
    } else if (frame->type == INNO_CFRAME_TEXT) {
      inno_text *p = &frame->texts[i];
      printf("[LIDAR-%d]   *text[%5u] "
             "x=%f y=%f z=%f "
             "alpha=%f c=%d sty=%d text=%s\r\n",
             lidar_handle, i,
             p->x, p->y, p->z,
             p->alpha, p->color, p->style, p->text);
    } else if (frame->type == INNO_CFRAME_ALARM) {
      struct inno_alarm_message &a = frame->alarm[0];
      printf("[LIDAR-%d]   *alarm[%5u] "
             "level=%d type=%d message=%s\n",
             lidar_handle, i,
             a.level, a.code, a.message);
    } else {
      fprintf(stderr, "bad type %d\n", frame->type);
    }
  }

  if (setup_write_socket(output_format_g) >= 0) {
    // write to write_socket
    int ret = write_to_write_socket_cframe(lidar_handle,
                                           context, frame);
    if (ret < 0) {
      fprintf(stderr, "Client disconnect.\n");
      close(server_write_fd_g);
      server_write_fd_g = -1;
      frame_written_g = 0;
    } else {
      printf("[LIDAR-%d]   write %d bytes to client, %d in this session.\n",
             lidar_handle, ret, ++frame_written_g);
    }
  }
  pthread_mutex_unlock(&write_mutex_s);
  return 0;
}

void inno_lidar_log_test_callback(enum inno_log_level level,
                                  const char *header1,
                                  const char *header2,
                                  const char *msg) {
  fprintf(stderr, "level=%d header1=%s header2=%s body=%s\n",
          level, header1, header2, msg);
}

void usage(const char *argv0) {
  fprintf(stderr,
          "usage: %s -n LIDAR_IP [-m MODEL] [--server-port PORT] "
          "[-y YAML_FILE] [-d DURATION-IN-SECOND] [--output-csv CSV_FILE] "
          "[-v] [--compact || --ps31full || --ps32full] "
          "[--static-perception[=STATIC_FRAME_INTERVAL]]"
          "[-b BACKGROUND_FILES]\n"
          "OR\n"
          "       %s -f DATA_FILE [-s SPEED] "
          "[-y YAML_FILE] [-d DURATION-IN-SECOND] [--output-csv CSV_FILE] "
          "[-v] [--compact || --ps31full || --ps32full] "
          "[--static-perception[=STATIC_FRAME_INTERVAL]]"
          "[-b BACKGROUND_FILES]\n",
          argv0, argv0);
  exit(1);
}

int main(int argc, char *argv[]) {
  const char *yamls[MAX_INS * 2];
  // const char *background_input[MAX_INS * 2];
  const char *ips[MAX_INS];
  const char *files[MAX_INS];
  const char *model = "REV_E";
  int speed = 20;
  double duration = 10000000;
  int repeat = 1;
  int yaml_instance = 0;
  int background_instance = 0;
  int get_version = 0;

  static struct option long_options[] = {
    /* These options set a flag. */
    {"version", no_argument, &get_version, 1},
    {"verbose", no_argument, &verbose_flag_g, 1},
    {"brief",   no_argument, &verbose_flag_g, 0},
    {"full", no_argument, &output_format_g, 0},
    {"compact", no_argument, &output_format_g, 3},
    {"ps31full", no_argument, &output_format_g, 1},
    {"ps32full", no_argument, &output_format_g, 2},
    {"yaml",  required_argument, 0, 'y'},
    {"background-input", required_argument, 0, 'b'},
    {"file",  required_argument, 0, 'f'},
    {"output-csv",  required_argument, 0, 'o'},
    {"speed",  required_argument, 0, 's'},
    {"model",  required_argument, 0, 'm'},
    {"duration",  required_argument, 0, 'd'},
    {"repeat",  required_argument, 0, 'r'},
    {"ip",  required_argument, 0, 'n'},
    {"udp-ip",  required_argument, 0, 'u'},
    {"server-port",  required_argument, 0, 'p'},
    {"static-perception", optional_argument, 0, 't'},
    {0, 0, 0, 0}
  };

  /* getopt_long stores the option index here. */
  int c;
  int index;

  while (1) {
    int option_index = 0;
    c = getopt_long(argc, argv, "i:y:f:r:s:vm:d:hn:p:ct::b:",
                    long_options, &option_index);

    /* Detect the end of the options. */
    if (c == -1) {
      break;
    }

    switch (c) {
      case 0:
        /* If this option set a flag, do nothing else now. */
        if (long_options[option_index].flag != 0) {
          break;
        }
        printf("option %s", long_options[option_index].name);
        if (optarg)
          printf(" with arg %s", optarg);
        printf("\n");
        break;

      case 'y':
        index = optind - 1;
        while (index < argc) {
          index++;
          if (argv[index - 1][0] != '-') {
            if (yaml_instance < MAX_INS * 2) {
              yamls[yaml_instance++] = strdup(argv[index - 1]);
            }
          } else {
            break;
          }
        }
        optind = index - 1;
        break;

      case 'b':
        index = optind - 1;
        while (index < argc) {
          index++;
          if (argv[index - 1][0] != '-') {
            if (background_instance < MAX_INS * 2) {
           // background_input[background_instance++] = strdup(argv[index - 1]);
            }
          } else {
            break;
          }
        }
        optind = index - 1;
        break;

      case 'f':
        index = optind - 1;
        while (index < argc) {
          index++;
          if (argv[index - 1][0] != '-') {
            if (file_instance_g < MAX_INS) {
              files[file_instance_g++] = strdup(argv[index - 1]);
            }
          } else {
            break;
          }
        }
        optind = index - 1;
        break;

      case 'n':
        index = optind - 1;
        while (index < argc) {
          index++;
          if (argv[index - 1][0] != '-') {
            if (ip_instance_g < MAX_INS) {
              ips[ip_instance_g++] = strdup(argv[index - 1]);
            }
          } else {
            break;
          }
        }
        optind = index - 1;
        break;

      case 'm':
        model = optarg;
        break;

      case 's':
        speed = atoi(optarg);
        break;

      case 'd':
        if (1 != sscanf(optarg, "%lf", &duration)) {
          usage(argv[0]);
        }
        break;

      case 'r':
        repeat = atoi(optarg);
        break;

      case 'p':
        server_port_g = atoi(optarg);
        break;

      case 'o':
        csv_filename_g = optarg;
        break;

      case 'u':
        udp_ip_g = strdup(optarg);
        break;

      case 'v':
        verbose_flag_g = 1;
        break;

      case 'c':
        output_format_g = 3;
        break;

      case 't':
        static_perception_flag_g = 1;
        if (optarg) {
          static_frame_interval = atoi(optarg);
        }
        break;

      case 'h':
        usage(argv[0]);

      case '?':
        /* getopt_long already printed an error message. */
        abort();

      default:
        abort();
    }
  }

  if (get_version) {
    printf("%s\n", inno_api_version());
    exit(0);
  }
  if (file_instance_g + ip_instance_g == 0 || speed < 0 ||
      !model || duration < 0 || repeat <= 0) {
    usage(argv[0]);
  }

  printf("Use Innovusion LIDAR API version=%s built_time=%s\n",
         inno_api_version(), inno_api_build_time());
  printf("LIDAR model %s\n", model);
  for (int i = 0; i < ip_instance_g; i++) {
    printf("Use live LIDAR %s\n", ips[i]);
    if (i < yaml_instance) {
      printf("  Use yaml file: %s\n", yamls[i]);
    }
  }
  for (int i = 0; i < file_instance_g; i++) {
    printf("Process file %s\n", files[i]);
    if (i + ip_instance_g < yaml_instance) {
      printf("  Use yaml file: %s\n", yamls[i + ip_instance_g]);
    }
  }
  if (file_instance_g) {
    printf("Speed is %dMB/s\n", speed);
  }
  printf("Number of LIDAR instances live=%d file=%d\n",
         ip_instance_g, file_instance_g);
  printf("Duration is %f seconds\n", duration);
  if (server_port_g) {
    printf("Server port is %d\n", server_port_g);
  }

  signal(SIGPIPE, SIG_IGN);
  inno_lidar_setup_sig_handler();
  inno_lidar_set_logs(-1, -1, inno_lidar_log_test_callback);
  inno_lidar_set_log_level(verbose_flag_g ?
                           INNO_LOG_EVERYTHING_LEVEL :
                           INNO_LOG_INFO_LEVEL);

  if (use_tcp()) {
    setup_tcp_server_socket();
  }

  int instances = ip_instance_g + file_instance_g;
  for (int round = 0; round < repeat; round++) {
    for (int i = 0; i < instances; i++) {
      char buf[64];
      snprintf(buf, sizeof(buf), "test-lidar-%d", i);
      int handle;
      const char *info = NULL;
      if (i < ip_instance_g) {
        info = ips[i];
        handle = inno_lidar_open_live(buf, info, 8001, true);
        if (handle > 0) {
          char buffer[512];
          int r = 0;
          r = inno_lidar_get_fw_version(handle, buffer, sizeof(buffer));
          if (r > 0) {
            printf("get_fw_version: r=%d content=%s\n", r, buffer);
          }
          r = inno_lidar_get_sn(handle, buffer, sizeof(buffer));
          if (r > 0) {
            printf("get_sn: r=%d content=%s\n", r, buffer);
          }
          r = inno_lidar_get_model(handle, buffer, sizeof(buffer));
          if (r > 0) {
            printf("get_model: r=%d content=%s\n", r, buffer);
          }
        }
      } else {
        info = files[i - ip_instance_g];
        handle = inno_lidar_open_file(buf, info, speed, 0, 0);
      }
      if (handle <= 0) {
        fprintf(stderr, "inno_lidar_open %s failed\n", info);
        return -1;
      }
      int ret = inno_lidar_set_parameters(handle, model, "",
                                          i < yaml_instance ? yamls[i] : NULL);
      if (ret != 0) {
        fprintf(stderr, "inno_lidar_set_parameters %s failed %d\n", info, ret);
        return -2;
      }

      ret = inno_lidar_set_reflectance_mode(handle,
                                            REFLECTANCE_MODE_INTENSITY);
      if (ret != 0) {
        fprintf(stderr, "inno_lidar_set_reflectance %s failed %d\n",
                info, ret);
        return -2;
      }

      inno_lidar_set_callbacks(handle, inno_lidar_alarm_callback,
                               (static_perception_flag_g ||
                                output_format_g == 2 ||  output_format_g == 3) ?
                               NULL :
                               inno_lidar_frame_callback,
                               NULL,
                               reinterpret_cast<void *>(i));
      if (static_perception_flag_g) {
        if (i < background_instance) {
       // int ret = inno_lidar_set_background_file(handle, background_input[i]);
          if (ret != 0) {
            fprintf(stderr, "inno_lidar_set_background_file %s failed %d\n",
                    info, ret);
            return -3;
          }
        }
        inno_lidar_set_callbacks_2(handle, inno_lidar_cframe_callback,
                                   INNO_CFRAME_CPOINT,
                                   reinterpret_cast<void *>(i));
     // inno_lidar_set_perception_mode(handle, INNO_STATIC_PERCEPTION,
     //                                static_frame_interval);
      } else if (output_format_g == 2) {
        inno_lidar_set_callbacks_2(handle, inno_lidar_cframe_callback,
                                   INNO_CFRAME_POINT,
                                   reinterpret_cast<void *>(i));
      } else if (output_format_g == 3) {
        inno_lidar_set_callbacks_2(handle, inno_lidar_cframe_callback,
                                   INNO_CFRAME_CPOINT,
                                   reinterpret_cast<void *>(i));
        // use external memory pool
        unsigned int bf_sz = inno_lidar_get_min_buffer_size_per_cframe(handle);
        unsigned int bf_count = 10;
        void *buffer = malloc(bf_sz * bf_count);
        inno_lidar_set_external_cframe_mem_pool(handle, buffer,
                                                bf_sz,
                                                bf_count);
      }
      inno_lidar_start(handle);
      handles_g[i] = handle;
    }

    if (duration > 100) {
      sleep(duration);
    } else {
      usleep(duration * 1000000);
    }

    for (int i = 0; i < instances; i++) {
      inno_lidar_stop(handles_g[i]);
      inno_lidar_close(handles_g[i]);
      handles_g[i] = -1;
    }
    printf("Done round %d\n", round);
  }
  return 0;
}
